import { configureStore } from '@reduxjs/toolkit';
import { authSlice } from './Auth/store/index';
import { usersSlice } from './Admin/store/users/usersSlice'; 
import cartReducer from './Store/Store/slices/cartSlice'; 
import carouselReducer from './Store/carouselSlice'; 

export const store = configureStore({
  reducer: {
    users: usersSlice.reducer, 
    auth: authSlice.reducer,
    cart: cartReducer,
    carousel: carouselReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

/// <reference types="vite/client" />
// src/vite.config.ts
export default defineConfig({
    build: {
      rollupOptions: {
        output: {
          manualChunks(id) {
            if (id.includes('node_modules')) {
              return 'vendor';
            }
            if (id.includes('src/Admin')) {
              return 'admin';
            }
            if (id.includes('src/Users')) {
              return 'users';
            }
            if (id.includes('src/Store')) {
              return 'store';
            }
          }
        }
      }
    }
  });

function defineConfig(arg0: { build: { rollupOptions: { output: { manualChunks(id: any): "vendor" | "admin" | "users" | "store" | undefined; }; }; }; }) {
    throw new Error("Function not implemented.");
}
// src/Admin/hooks/useFacturas.ts
import { useState, useEffect } from "react";
import { PaymentProductDTO, FacturasPage, getFacturasPage } from "../services/facturaService";

interface PaginatorState {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

export const useFacturas = (currentPage: number, searchTerm: string) => {
  const [facturas, setFacturas] = useState<PaymentProductDTO[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    number: 0,
    totalPages: 1,
    first: true,
    last: false,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchFacturasPage = async (page: number, search: string) => {
    try {
      setIsLoading(true);
      setError(null);

      // Ahora se pasa el parámetro "search" a la función del servicio
      const response = await getFacturasPage(page, 6, search);
      console.log("aqui la informacion de la factura",response);
      const data: FacturasPage = response.data;
      setFacturas(data.content);
      setPaginator({
        number: data.number,
        totalPages: data.totalPages,
        first: data.first,
        last: data.last,
      });
    } catch (err: any) {
      console.error(err);
      setError("Error al obtener las facturas de productos aprobados.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchFacturasPage(currentPage, searchTerm);
  }, [currentPage, searchTerm]);

  return {
    facturas,
    paginator,
    isLoading,
    error,
    reloadFacturas: fetchFacturasPage, // Por si necesitas recargar manualmente
  };
};
import { useEffect, useState } from 'react';
import { getTotalRevenue, getAdminDashboardRevenue, AdminDashboardRevenue } from '../services/FinancialService';

export const useFinancialData = () => {
  const [totalRevenue, setTotalRevenue] = useState<number | null>(null);
  const [adminRevenueData, setAdminRevenueData] = useState<AdminDashboardRevenue | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [total, adminData] = await Promise.all([
          getTotalRevenue(),
          getAdminDashboardRevenue()
        ]);

        setTotalRevenue(total);
        setAdminRevenueData(adminData);
      } catch (err: any) {
        console.error('Error fetching financial data:', err);
        setError('Error fetching financial data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  return {
    totalRevenue,
    adminRevenueData,
    loading,
    error
  };
};
// src/hooks/useGroupClasses.ts
import { useState } from 'react';
import { createGroupClass, assignTrainerToClass, CreateGroupClassData } from '../services/groupClassService';

export const useGroupClasses = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleCreateClass = async (data: CreateGroupClassData) => {
    try {
      setLoading(true);
      setError(null);
      const result = await createGroupClass(data);
      return result;
    } catch (err: any) {
      setError(err.message || 'Error al crear la clase grupal');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const handleAssignTrainer = async (classId: number, trainerId: number) => {
    try {
      setLoading(true);
      setError(null);
      const result = await assignTrainerToClass(classId, trainerId);
      return result;
    } catch (err: any) {
      setError(err.message || 'Error al asignar entrenador');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return {
    loading,
    error,
    handleCreateClass,
    handleAssignTrainer
  };
};
// src/Admin/hooks/usePlanes.ts
import { useState, useEffect } from "react";
import { PaymentPlanDTO, PlanesPage, getPlanesPage } from "../services/facturaService";

interface PaginatorState {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

export const usePlanes = (currentPage: number, searchTerm: string) => {
  const [planes, setPlanes] = useState<PaymentPlanDTO[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    number: 0,
    totalPages: 1,
    first: true,
    last: false,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchPlanesPage = async (page: number, search: string) => {
    try {
      setIsLoading(true);
      setError(null);

      // Asumiendo que getPlanesPage acepta un tercer parámetro para búsqueda
      const response = await getPlanesPage(page, 6, search);
      const data: PlanesPage = response.data;
      setPlanes(data.content);
      setPaginator({
        number: data.number,
        totalPages: data.totalPages,
        first: data.first,
        last: data.last,
      });
    } catch (err: any) {
      console.error(err);
      setError("Error al obtener los pagos aprobados de planes.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchPlanesPage(currentPage, searchTerm);
  }, [currentPage, searchTerm]);

  return {
    planes,
    paginator,
    isLoading,
    error,
    reloadPlanes: fetchPlanesPage, // por si necesitas recargar manualmente
  };
};
// src/components/ProductCrud/hooks/useProductCrud.ts

import { useState, useEffect } from 'react';
import Swal from 'sweetalert2';
import {
  getAllProducts,
  getProductsPage,
  createProduct,
  updateProduct,
  deleteProduct,
  getAllCategories
} from '../../Store/services/ProductService';

import { Product } from '../../Store/interface/Product';

interface Category {
  id: number;
  name: string;
}

interface PaginatorState {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

export const useProductCrud = (currentPage: number, searchTerm: string) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    number: 0,
    totalPages: 1,
    first: true,
    last: false,
  });
  const [categories, setCategories] = useState<Category[]>([]);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [openDialog, setOpenDialog] = useState(false);

  // Cargar categorías e inicial (similar a fetchAllAndFilter / fetchProductsPage)
  useEffect(() => {
    if (searchTerm.trim() === '') {
      fetchProductsPage();
      fetchCategories();
    } else {
      fetchAllAndFilter();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentPage, searchTerm]);

  // Obtener productos paginados
  const fetchProductsPage = async () => {
    try {
      const data = await getProductsPage(currentPage, 6);
    
      setProducts(data.content);
      setPaginator({
        number: data.number,
        totalPages: data.totalPages,
        first: data.first,
        last: data.last,
      });
    } catch (error) {
      console.error('Error al obtener productos paginados:', error);
    }
  };

  // Obtener *todos* y filtrar en front
  const fetchAllAndFilter = async () => {
    try {
      const all = await getAllProducts();
      const filtered = all.filter((p) =>
        p.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setProducts(filtered);
      setPaginator({
        number: 0,
        totalPages: 1,
        first: true,
        last: true,
      });
    } catch (error) {
      console.error('Error al obtener productos:', error);
    }
  };

  // Obtener categorías
  const fetchCategories = async () => {
    try {
      const categoriesData = await getAllCategories();
      setCategories(categoriesData);
    } catch (error) {
      console.error('Error al obtener categorías:', error);
    }
  };

  // Crear producto
  const handlerCreateProduct = async (formData: FormData) => {
    try {
      await createProduct(formData);
      Swal.fire('Producto creado', 'El producto ha sido creado con éxito.', 'success');
      await fetchProductsPage();
    } catch (error) {
      console.error('Error al crear producto:', error);
      Swal.fire('Error', 'Ocurrió un error al guardar el producto.', 'error');
    }
  };

  // Editar producto
  const handlerUpdateProduct = async (id: number, formData: FormData) => {
    console.log("aqui la form data",formData);
    try {
      await updateProduct(id, formData);
      Swal.fire('Producto actualizado', 'El producto ha sido actualizado con éxito.', 'success');
      await fetchProductsPage();
    } catch (error) {
      console.error('Error al actualizar producto:', error);
      Swal.fire('Error', 'Ocurrió un error al guardar el producto.', 'error');
    }
  };

  // Eliminar producto
  const handlerDeleteProduct = async (productId: number) => {
    try {
      await deleteProduct(productId);
      await fetchProductsPage();
      Swal.fire('Producto eliminado', 'El producto ha sido eliminado con éxito.', 'success');
    } catch (error) {
      console.error('Error al eliminar producto:', error);
      Swal.fire('Error', 'Ocurrió un error al eliminar el producto.', 'error');
    }
  };

  // Mostrar el modal en modo "Crear"
  const handleOpenCreate = () => {
    setSelectedProduct(null);
    setOpenDialog(true);
  };

  // Mostrar el modal en modo "Editar"
  const handleEdit = (product: Product) => {
    setSelectedProduct(product);
    setOpenDialog(true);
  };

  // Cerrar modal
  const handleCloseDialog = () => {
    setSelectedProduct(null);
    setOpenDialog(false);
  };

  return {
    products,
    paginator,
    categories,
    selectedProduct,
    openDialog,

    // funciones
    handlerCreateProduct,
    handlerUpdateProduct,
    handlerDeleteProduct,
    handleOpenCreate,
    handleEdit,
    handleCloseDialog,
  };
};
// src/Admin/hooks/useUsers.ts

import { useDispatch, useSelector } from 'react-redux';
import { addUser, removeUser, updateUser, loadingUsers, onUserSelectedForm, onOpenForm, onCloseForm, loadingError, updatePaginator } from '../../Admin/store/users/usersSlice';
import { UserInterface } from '../../Auth/Interfaces/UserInterface';
import * as userService from '../../Admin/services/UserService';
import { useState } from 'react';
import apiClient from '../../Apis/apiConfig';

export const useUsers = () => {
  const dispatch = useDispatch();
  const { users, paginator, visibleForm, userSelected, errors, isLoading } = useSelector((state: any) => state.users);
  const [searchTerm, setSearchTerm] = useState('');

  const getUsers = async (page: number) => {
    try {
      const response = await userService.findAllPages(page, searchTerm);
      dispatch(loadingUsers(response.data.content));
      dispatch(updatePaginator({
        number: response.data.number,
        totalPages: response.data.totalPages,
        first: response.data.first,
        last: response.data.last,
      }));
    } catch (error) {
      console.error(error);
      dispatch(loadingError({ errorMessage: 'Error al cargar usuarios' }));
    }
  };

  const handlerOpenForm = () => {
    dispatch(onOpenForm());
  };

  const handlerCloseForm = () => {
    dispatch(onCloseForm());
  };

  const handlerUserSelectedForm = (user: UserInterface) => {
    dispatch(onUserSelectedForm(user));
  };

  const handlerAddUser = async (user: UserInterface) => {
    try {
      // Crear el usuario
      const response = await userService.save(user);
      const createdUser = response.data;
      console.log("usuario creado",createdUser)

      dispatch(addUser(createdUser));

      // Si el usuario es un trainer, asignar el rol de trainer y crear PersonalTrainer
      if (user.trainer) {
        console.log(user.trainer);
        const trainerData = {
          specialization: (user as any).specialization,
          experienceYears: (user as any).experienceYears,
          availability: (user as any).availability,
          monthlyFee: (user as any).monthlyFee,
          title: (user as any).title,
          studies: (user as any).studies,
          certifications: (user as any).certifications,
          description: (user as any).description,
          instagramUrl: (user as any).instagramUrl,      // <-- del root
          whatsappNumber: (user as any).whatsappNumber

        };
        console.log("trainerData",trainerData);
        const formData = new FormData();


        formData.append('specialization', trainerData.specialization);
        formData.append('experienceYears', String(trainerData.experienceYears));
        formData.append('availability', String(trainerData.availability));
        formData.append('monthlyFee', String(trainerData.monthlyFee));
        formData.append('title', trainerData.title);
        formData.append('studies', trainerData.studies);
        formData.append('certifications', trainerData.certifications);
        formData.append('description', trainerData.description);
        
        if (trainerData.instagramUrl) {
          formData.append('instagramUrl', trainerData.instagramUrl);
        }
        if (trainerData.whatsappNumber) {
          formData.append('whatsappNumber', trainerData.whatsappNumber);
        }
        
        // Y si hay un archivo
        if (user.certificationFile) {
          formData.append('certificationFile', user.certificationFile);
        }
  
        // Si se subió archivo, lo añadimos:
        if (user.certificationFile) {
          formData.append('certificationFile', user.certificationFile);
        }
  
        // Llamamos a /trainers/{createdUser.id}/assign
        const response = await apiClient.post(
          `/trainers/${createdUser.id}/assign`,
          formData,
          {
            headers: { 'Content-Type': 'multipart/form-data' },
          }
        );
        
        console.log(response);
      }

    } catch (error: any) {
      console.error(error);
      if (error.response && error.response.data) {
        dispatch(loadingError({ errorMessage: error.response.data.message || 'Error al crear usuario' }));
      } else {
        dispatch(loadingError({ errorMessage: 'Error al crear usuario' }));
      }
    }
  };

  const handlerRemoveUser = async (id: string) => {
    try {
      await userService.remove(id);
      dispatch(removeUser(id));
    } catch (error) {
      console.error(error);
      dispatch(loadingError({ errorMessage: 'Error al eliminar usuario' }));
    }
  };

  return {
    users,
    visibleForm,
    handlerOpenForm,
    handlerCloseForm,
    handlerUserSelectedForm,
    handlerAddUser,
    handlerRemoveUser,
    paginator,
    searchTerm,
    setSearchTerm,
    getUsers,
    errors,
    isLoading,
  };
};
// UserInterface.ts
export interface UserState {
    id?: string;
    username: string;
    password: string;
    email: string;
    admin: boolean;
    trainer: boolean;
      // Agregar la propiedad 'role'
    role: string;
    // O si manejas roles como un array:
    roles: string[];
    // Otros campos...
    profileImageUrl: string;
}
// src/Admin/services/availabilityService.ts

import apiClient from '../../Apis/apiConfig';

export interface PersonalTrainerDto {
  id: number;
  username: string;
  email: string;
  specialization: string;
  experienceYears: number;
  availability: boolean;
  profileImageUrl: string;
  title: string;
  studies: string;
  certifications: string;
  description: string;
}

export interface TrainerAvailabilityRequest {
  day: string;       // "YYYY-MM-DD"
  startTime: string; // "HH:mm"
  endTime: string;   // "HH:mm"
}

export const fetchAvailableTrainers = async (
  day: string,        // "YYYY-MM-DD"
  startTime: string,  // "HH:mm"
  endTime: string     // "HH:mm"
): Promise<PersonalTrainerDto[]> => {
  const response = await apiClient.get('/trainer-schedule/available', {  // Endpoint corregido
    params: { day, startTime, endTime },
  });
  console.log("ACA LA RESPONSE", response);
  return response.data;
};


import apiClient from '../../Apis/apiConfig';

// Obtener todas las imágenes del carrusel
export const getCarouselImages = async () => {
  try {
    const response = await apiClient.get('/carousel/images');
    return response.data;
  } catch (error) {
    console.error('Error al obtener imágenes del carrusel:', error);
    throw error;
  }
};

// Subir una nueva imagen al carrusel
export const uploadCarouselImage = async (
    file: File,
    caption: string,
    orderNumber: number
  ) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('caption', caption);
    formData.append('order', orderNumber.toString());
  
    try {
      const response = await apiClient.post('/carousel/images', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error al subir la imagen del carrusel:', error);
      throw error;
    }
  };
  
  // Actualizar una imagen existente
  export const updateCarouselImage = async (
    id: number,
    caption?: string,
    orderNumber?: number
  ) => {
    console.log(id,
      caption,
      orderNumber)
    const formData = new FormData();
    if (caption) formData.append('caption', caption);
    if (orderNumber !== undefined) formData.append('order', orderNumber.toString());
  
    try {
      const response = await apiClient.put(`/carousel/images/${id}`, formData);
      console.log("response",response);
      return response.data;
    } catch (error) {
      console.error('Error al actualizar la imagen:', error);
      throw error;
    }
  };
  
  // Eliminar una imagen del carrusel
  export const deleteCarouselImage = async (id: number) => {
    try {
      await apiClient.delete(`/carousel/images/${id}`);
    } catch (error) {
      console.error('Error al eliminar la imagen del carrusel:', error);
      throw error;
    }
  };
  // src/Admin/services/facturaService.ts

import apiClient from "../../Apis/apiConfig";
import { AxiosResponse } from "axios";
// import { PaymentPlanDTO } from "./FinancialService";
import { PaymentPlanDTO, PaymentProductDTO  }from "../../Store/interface/Payment"

// Define la interfaz de un PaymentProductDTO
/*
export interface PaymentProductDTO {
  paymentId: number;
  username: string;
  paymentMethod: string | null;
  paymentDate: string;  // o Date
  transactionAmount: number;
  productName: string;
} */

// Define la interfaz de la estructura paginada que retorna el backend
export interface FacturasPage {
  content: PaymentProductDTO[];
  totalPages: number;
  number: number;
  first: boolean;
  last: boolean;
}

export interface PlanesPage {
  content: PaymentPlanDTO[];
  totalPages: number;
  number: number;
  first: boolean;
  last: boolean;
}

/*
export interface PaymentPlanDTO {
  paymentId: number;
  planId: number;
  username: string;
  transactionAmount: number;
  status: string;
  paymentMethod: string | null;
  paymentDate: string; // o Date
  subscriptionStartDate: string; // "2024-12-07"
  subscriptionEndDate: string;   // "2025-12-07"
  trainerSubscriptionStartDate: string; 
  trainerSubscriptionEndDate: string;
  personalTrainerName: string;
} */

  export const getFacturasPage = async (
    page: number,
    size = 6,
    search = ""
  ): Promise<AxiosResponse<FacturasPage>> => {
    return apiClient.get(`/payment/approved_products/page/${page}`, {
      params: { size, search },
    });
  };
  

  export const getPlanesPage = async (
    page: number,
    size = 6,
    search = ""
  ): Promise<AxiosResponse<PlanesPage>> => {
    return apiClient.get(`/payment/approved_plans/page/${page}`, {
      params: { size, search }, // Agregamos el parámetro de búsqueda
    });
  };
import apiClient from '../../Apis/apiConfig';

export const getTotalRevenue = async (): Promise<number> => {
  const response = await apiClient.get('/payment/total-revenue');
  // La respuesta tiene la forma { "totalRevenue": 7795000.00 }
  return response.data.totalRevenue;
};

export interface PlanRevenue {
  [planName: string]: number;
}

export interface ServiceRevenue {
  personalTrainer: number;
  planAndTrainer: number;
  plan: number;
}

export interface AdminDashboardRevenue {
  planRevenue: PlanRevenue;
  serviceRevenue: ServiceRevenue;
}

export const getAdminDashboardRevenue = async (): Promise<AdminDashboardRevenue> => {
  const response = await apiClient.get('/payment/admin-dashboard-revenue');
  // Estructura:
  // {
  //   "planRevenue": {
  //       "Trimestral": 230000.00,
  //       "mensual": 475000.00,
  //       "anual": 800000.00
  //   },
  //   "serviceRevenue": {
  //       "personalTrainer": 1060000.00,
  //       "planAndTrainer": 6075000.00,
  //       "plan": 85000.00
  //   }
  // }
  return response.data;
};
// src/api/groupClassService.ts
import apiClient from '../../Apis/apiConfig';

export interface CreateGroupClassData {
  className: string;
  startTime: string;   // formato ISO 8601, ej: '2024-12-19T08:00:00'
  endTime: string;
  maxParticipants: number;
}

export const createGroupClass = async (data: CreateGroupClassData) => {
  const response = await apiClient.post('/group-classes/create', data);
  return response.data;
};

export const assignTrainerToClass = async (classId: number, trainerId: number) => {
  const response = await apiClient.post(`/group-classes/${classId}/assign-trainer?trainerId=${trainerId}`);
  return response.data;
};
// src/api/gymInfoService.ts
import apiClient from '../../Apis/apiConfig';
import { GymInfoValues } from '../../Admin/pages/GymInfoForm';

export const createGymInfo = async (data: GymInfoValues) => {
    try {
      const response = await apiClient.post('/api/gym-info', data);
      return response.data;
    } catch (error) {
      console.error('Error al crear la información del gym:', error);
      throw error;
    }
  };
  
  // Nuevos métodos para obtener y actualizar
  export const getGymInfo = async (): Promise<GymInfoValues> => {
    try {
      const response = await apiClient.get('/api/gym-info');
      return response.data;
    } catch (error) {
      console.error('Error al obtener la información del gym:', error);
      throw error;
    }
  };
  
  export const updateGymInfo = async (id: number, data: GymInfoValues) => {
    try {
      const response = await apiClient.put(`/api/gym-info/${id}`, data);
      return response.data;
    } catch (error) {
      console.error('Error al actualizar la información del gym:', error);
      throw error;
    }
  };
import apiClient  from "../../Apis/apiConfig";
import { UserInterface } from '../../Auth/Interfaces/UserInterface';


const BASE_URL = '/users';

export const findAll = async() => {
  try {
 
      const response = await apiClient.get(BASE_URL);

      return response;
  } catch (error) {
      console.error("[UserService] Error en findAll:", error);
      throw error;
  }
}

export const findAllPages = async (page = 0, search = '') => {
  try {
 
    const response = await apiClient.get(`${BASE_URL}/page/${page}`, {
      params: {
        search,
      },
    });

    return response;
  } catch (error) {
    console.error("[UserService] Error en findAllPages:", error);
    throw error;
  }
};
  

export const save = async (user: UserInterface) => {
  const { trainerDetails, ...userData } = user;
  console.log("aqui los datos de usuario",userData);
  console.log("aqui los datos de trainer",trainerDetails);
  
  const response = await apiClient.post(BASE_URL, {
    ...userData,
    ...(trainerDetails ? trainerDetails : {}),
  });
  console.log("AQUI ESTA LA RESPUESTA",response);

  return response;
};

  
  export const update = async ({ id, username, email, admin, trainer }: UserInterface) => {
    return await apiClient.put(`${BASE_URL}/${id}`, { username, email, admin, trainer });
  };
  


export const remove = async (id: string) => {
    await apiClient.delete(`${BASE_URL}/${id}`);
};

export * from './users/usersSlice';// src/Admin/store/users/usersSlice.ts

import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { UserInterface } from "../../../Auth/Interfaces/UserInterface";

// Define la interfaz para la paginación
interface Paginator {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

// Define la interfaz para un usuario y el estado inicial
export const initialUserForm: UserInterface = {
  id: "",
  username: '',
  password: '',
  email: '',
  admin: false,
  trainer: false,
  role: "",
  roles: []
};

const initialErrors = {
  username: '',
  password: '',
  email: '',
};

const initialState = {
  users: [] as UserInterface[],
  paginator: { number: 0, totalPages: 1, first: true, last: false } as Paginator,
  userSelected: initialUserForm,
  visibleForm: false,
  errors: initialErrors,
  isLoading: true,
};

// Crear el slice de usuarios
export const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    addUser: (state, action: PayloadAction<UserInterface>) => {
      state.users = [
        ...state.users,
        {
          ...action.payload,
        }
      ];
      state.userSelected = initialUserForm;
      state.visibleForm = false;
    },
    removeUser: (state, action: PayloadAction<string>) => { 
      state.users = state.users.filter(user => user.id !== action.payload);
    },
    updateUser: (state, action: PayloadAction<UserInterface>) => {
      state.users = state.users.map(u => {
        if (u.id === action.payload.id) {
          return {
            ...action.payload,
          };
        }
        return u;
      });
      state.userSelected = initialUserForm;
      state.visibleForm = false;
    },
    loadingUsers: (state, action: PayloadAction<UserInterface[]>) => {
      state.users = action.payload;
      state.isLoading = false;
    },
    updatePaginator: (state, action: PayloadAction<Paginator>) => {
      state.paginator = action.payload;
    },
    onUserSelectedForm: (state, action: PayloadAction<UserInterface>) => {
      state.userSelected = action.payload;
      state.visibleForm = true;
    },
    onOpenForm: (state) => {
      state.visibleForm = true;
    },
    onCloseForm: (state) => {
      state.visibleForm = false;
      state.userSelected = initialUserForm;
    },
    loadingError: (state, action: PayloadAction<Partial<typeof initialErrors>>) => {
      state.errors = { ...state.errors, ...action.payload };
    }
  }
});

export const {
  addUser,
  removeUser,
  updateUser,
  loadingUsers,
  onUserSelectedForm,
  onOpenForm,
  onCloseForm,
  loadingError,
  updatePaginator,
} = usersSlice.actions;

export default usersSlice.reducer;
// src/api/apiClient.ts

import axios from 'axios';

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
});

// Interceptor para agregar el token de autenticación en cada solicitud
apiClient.interceptors.request.use(
  (config) => {
    const token = sessionStorage.getItem('token');

    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    return config;
  },
  (error) => {
    console.error('[API Client] Error en la solicitud:', error);
    return Promise.reject(error);
  }
);

export default apiClient;
// src/Auth/hooks/useAuth.ts

import { useNavigate } from 'react-router-dom';
import Swal from 'sweetalert2';
import { loginUser } from '../services/authService';
import { useDispatch, useSelector } from 'react-redux';
import { onLogin, onLogout, updateProfile } from '../store/auth/authSlice';

import { RootState } from '../../store';
import { AxiosError } from 'axios';
import { UserInterface } from '../Interfaces/UserInterface';
import apiClient from '../../Apis/apiConfig';
export const useAuth = () => {
  const dispatch = useDispatch();
  const { user, isAdmin, trainer, isAuth, roles, token } = useSelector(
    (state: RootState) => state.auth
  );
  const navigate = useNavigate();

  // Handler para el login
  const handlerLogin = async (
    { email, password }: LoginCredentials,
    from?: string // Agregamos el parámetro 'from' opcional
  ) => {
    try {
      const response = await loginUser({ email, password });


      const token = response.data.token;
      console.log("aqui el token",token);
      const claims = JSON.parse(window.atob(token.split(".")[1]));
      console.log("aqui los claims",claims);


      // Extraer roles
      let rolesArray: string[] = [];

if (claims.authorities) {
  let authorities = claims.authorities;
  // Si es un string JSON, parsear.
  if (typeof authorities === 'string') {
    try {
      authorities = JSON.parse(authorities);
    } catch (e) {
      authorities = [];
    }
  }
  // Filtrar a strings
  if (Array.isArray(authorities)) {
    rolesArray = authorities.map((r: any) => (typeof r === 'string' ? r : ''));
  }
}

const user: UserInterface = {
  id: claims.id || 0,
  username: claims.username || '',
  email: claims.sub || email,
  admin: claims.isAdmin || false,
  trainer: claims.isTrainer || false,
  // <-- ¡AQUÍ!: roles como array de strings
  roles: rolesArray,
  profileImageUrl: claims.profileImageUrl || '',
};
      console.log("aqui el usuario",user);
      if (user.trainer) {
        console.log("AQUI EDELGARD entro al if user.trainer ",user);
        try {
          const trainerResponse = await apiClient.get(`/trainers/findByUserId/${user.id}`);
          console.log("aca deberia cambiarle el id",trainerResponse);
          const trainerData = trainerResponse.data;
          console.log("Trainer encontrado:", trainerData);
      
          // Reemplazar el id de usuario con el id del entrenador
          user.id = trainerData.id;
      
          // ACTUALIZA EL TRAINER ID EN REDUX
          dispatch(updateProfile({
            ...user,
            id: trainerData.id  // Reemplazamos el id con el del trainer
          }));
        } catch (error) {
          console.error("Error obteniendo trainerId:", error);
        }
      }
      



      dispatch(onLogin({
        user,
        roles: rolesArray,
        isAdmin: user.admin,
        trainer: user.trainer,
        token
      }));
  
      // Guardar en sessionStorage
      sessionStorage.setItem('login', JSON.stringify({
        isAuth: true,
        isAdmin: user.admin,
        trainer: user.trainer,
        user,
        roles: rolesArray,
      }));
      sessionStorage.setItem('token', `${token}`);
  

      // Redirigir al usuario según 'from' o su rol
      if (from) {
        navigate(from);
      } else if (user.admin) {
        console.log("Navegando a /admin/dashboard para admin");
        navigate('/admin/dashboard');
      } else if (user.trainer) {
        console.log("Navegando a /trainers para entrenador");
        navigate('/trainers/dashboard');
      } else {
        console.log("Navegando a /dashboard para usuarios regulares");
        navigate('/dashboard');
      }
      

    } catch (error: unknown) {
      console.error("Error en el login:", error);
      const axiosError = error as AxiosError;
      if (axiosError.response?.status === 401) {
        Swal.fire('Error de inicio de sesión', 'Correo o contraseña incorrectos', 'error');
      } else if (axiosError.response?.status === 403) {
        Swal.fire('Acceso denegado', 'No tiene permisos para acceder', 'error');
      } else {
        Swal.fire('Error inesperado', axiosError.message, 'error');
      }
    }
  };

  // Handler para el logout
  const handlerLogout = () => {
    dispatch(onLogout());
    sessionStorage.removeItem('token');
    sessionStorage.removeItem('login');
    sessionStorage.clear();
    navigate('/auth/login');
  };

  return {
    login: {
      user,
      isAdmin,
      trainer,
      isAuth,
      roles,
      token,
    },
    handlerLogin,
    handlerLogout,
  };
}; 

export interface LoginCredentials {
    password: string;
    email: string;
}

export interface LoginCredentials {
    password: string;
    email: string;
}
import { UserInterface } from "../../Auth/Interfaces/UserInterface";


export interface AuthState {
  status: 'checking' | 'authenticated' | 'not-authenticated';
  user: UserInterface | null;
  isAuth: boolean;
  isAdmin: boolean;
  trainer?: boolean;
  roles: string[]; // Array de roles en formato string
  token: string | null;
  profileImageUrl?: string; 
  errorMessage?: string;
}

// src/interfaces/UserInterface.ts

// src/interfaces/UserInterface.ts

export interface Role {
  authority: string;
}

export interface TrainerDetails {
  specialization?: string;
  experienceYears?: number;
  availability?: boolean;
  monthlyFee?: number;
  title?: string;
  studies?: string;
  certifications?: string;
  description?: string;
  instagramUrl?: string;
  whatsappNumber?: string;
}

export interface UserInterface {
  id: number;
  username: string;
  password?: string;
  email: string;
  admin: boolean;
  trainer?: boolean;
  role?: Role | string;
  roles?: string[];
  profileImageUrl?: string;
  trainerDetails?: TrainerDetails;
    certificationFile?: File;
}







export * from './Login/LoginPage';
export * from './Register/RegisterPage';/* Centrado de contenedor en la pantalla */
.login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh; /* Ocupar toda la altura de la pantalla */
}

.row {
    width: 100%;
    display: flex;
    justify-content: center; /* Centra el contenido dentro de la fila */
}

.login-form-1 {
    width: 100%;
    max-width: 400px; /* Limita el ancho máximo del formulario */
    border-radius: 5px;
    box-shadow: 0 5px 8px 0 rgba(0, 0, 0, 0.2), 0 9px 26px 0 rgba(0, 0, 0, 0.19);
    padding: 20px;
    background-color: #ffffff;
}

.login-form-1 h3 {
    text-align: center;
    color: #333;
}

.login-container form {
    padding: 10px;
}

.btnSubmit {
    border-radius: 1rem;
    padding: 10px;
    border: none;
    cursor: pointer;
    margin: 10px 0;
}

.login-form-1 .btnSubmit {
    color: #fff;
    background-color: #0062cc;
}

.form-group {
    margin-bottom: 15px;
}

/* Estilo del enlace de "Regístrate" */
.link {
    color: #0062cc;
    font-weight: bold;
    text-decoration: none;
}

.link:hover {
    text-decoration: underline;
}
/* Estilo general del contenedor */
.register-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh; /* Ocupar toda la altura de la pantalla */
}

/* Estructura general del formulario */
.register-form-2 {
    width: 100%;
    max-width: 450px; /* Limita el ancho máximo del formulario */
    border-radius: 5px;
    box-shadow: 0 5px 8px 0 rgba(0, 0, 0, 0.2), 0 9px 26px 0 rgba(0, 0, 0, 0.19);
    padding: 30px;
    background-color: #ffffff;
}

/* Título del formulario */
.register-form-2 h3 {
    text-align: center;
    color: #333;
    margin-bottom: 20px;
}

/* Estilo de los inputs dentro del formulario */
.register-form-2 .form-group input {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    width: 100%;
    transition: border 0.3s ease;
}

/* Efecto hover en los inputs */
.register-form-2 .form-group input:focus {
    border: 1px solid #0062cc;
    outline: none;
}

/* Estilo general de los botones */
.btnSubmit {
    border-radius: 1rem;
    padding: 10px;
    border: none;
    cursor: pointer;
    margin: 10px 0;
}

/* Botón para registrar */
.register-form-2 .btnSubmit {
    color: #fff;
    background-color: #28a745; /* Verde para diferenciar del login */
}

/* Estilo de los grupos de formulario */
.form-group {
    margin-bottom: 15px;
}

/* Contenido adicional (links, textos) */
.register-container form {
    padding: 10px;
}

/* Estilo para los enlaces */
.link {
    color: #0062cc;
    font-weight: bold;
    text-decoration: none;
}

.link:hover {
    text-decoration: underline;
}

/* Estilo para mensajes de error */
.error-message {
    color: #ff4d4d;
    font-size: 0.9em;
    margin-top: -10px;
    margin-bottom: 10px;
    text-align: left;
}
/* Agrupación del input y el ícono */
.input-group {
    position: relative; /* Esto asegura que el ícono se posicione dentro del contenedor del input */
    display: flex;
    align-items: center;
}

/* Alineación del ícono de ojo dentro del campo de contraseña */
.input-group .input-group-text {
    position: absolute; /* El ícono se posiciona absolutamente dentro del contenedor relativo */
    right: 10px; /* Margen derecho para el ícono */
    top: 50%; /* Coloca el ícono en el centro vertical del input */
    transform: translateY(-50%); /* Ajusta la posición vertical al centro exacto */
    background-color: transparent; /* Elimina cualquier fondo por defecto del ícono */
    border: none; /* Sin borde */
    cursor: pointer; /* El cursor cambia al puntero cuando se pasa sobre el ícono */
    font-size: 1.2rem; /* Tamaño del ícono */
}

/* Aumentar el padding del input para evitar que el texto se superponga con el ícono */
.input-group input {
    padding-right: 40px; /* Espacio suficiente para el ícono */
}

/* Mantener el estilo del input cuando está enfocado */
.input-group input:focus {
    border-color: #0062cc; /* Color del borde al enfocar */
    outline: none;
}

// src/services/authService.ts

import axios from 'axios';
import apiClient from '../../Apis/apiConfig';
import { LoginCredentials } from '../Interfaces/AuthInterface';


export const loginUser = async ({ email, password }: LoginCredentials) => {
  try {
    console.log(
      "entro");
    const response = await apiClient.post('/login', { email, password });

    return response;
  } catch (error) {
    handleApiError(error);
  }
};

export const registerUser = async (userData: {
  username: string;
  email: string;
  password: string;
}) => {
  try {

    const response = await axios.post('http://localhost:8080/users/register', userData, {
      headers: {
        'Content-Type': 'application/json',
      },
    });
  
    return response.data;
  } catch (error) {
    handleApiError(error);
  }
};

// Función para manejar errores
const handleApiError = (error: unknown) => {
  if (axios.isAxiosError(error)) {
    // Retiras el throw de new Error y simplemente relanzas el error original
    throw error; 
  }
  // Si no es un AxiosError, aquí lanzas algo genérico
  throw new Error('Ocurrió un error desconocido.');
};



export * from './auth/authSlice';
// src/store/auth/authSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { AuthState } from '../../Interfaces/AuthState';
import { UserInterface } from '../../Interfaces/UserInterface';



const initialState: AuthState = {
  status: 'not-authenticated',
  user: null,
  isAuth: false,
  isAdmin: false,
  trainer: false,
  roles: [],
  token: null,
  errorMessage: undefined,
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    onChecking: (state) => {
      state.status = 'checking';
      state.user = null;
      state.isAuth = false;
      state.isAdmin = false;
      state.trainer = false;
      state.roles = [];
      state.errorMessage = undefined;
    },
    onLogin: (state, { payload }) => {
      state.status = 'authenticated';
      state.user = payload.user;
      state.isAuth = true;
      state.isAdmin = payload.isAdmin;
      state.trainer = payload.trainer;
      state.roles = payload.roles;
      state.token = payload.token; // Agrega esta línea
      state.errorMessage = undefined;
    },
    onLogout: (state) => {
      state.status = 'not-authenticated';
      state.user = null;
      state.isAuth = false;
      state.isAdmin = false;
      state.trainer = false;
      state.roles = [];
      state.errorMessage = undefined;
    },
    clearErrorMessage: (state) => {
      state.errorMessage = undefined;
    },
    updateProfile: (state, { payload }: PayloadAction<UserInterface>) => {
      if (state.user && state.user.id === payload.id) {
        state.user = payload;
        state.isAdmin = payload.admin;
        state.trainer = payload.trainer;
        state.roles = payload.roles || [];
      } else {
        // Asegura que cualquier actualización de trainer se refleje
        state.user = payload;
        state.trainer = payload.trainer;
      }
    },
  },
});

export const { onChecking, onLogin, onLogout, clearErrorMessage, updateProfile } = authSlice.actions;
export default authSlice.reducer;
.carousel-image {
  width: 100%;
  height: 500px;
  object-fit: contain;  /* Cambiar de cover a contain */
}

  
  .swiper-slide {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .footer-container {
    background-color: #000;
    color: white;
    padding: 40px 0;
    text-align: center;
    width: 100%;
    margin: 0;
  }
  
  .footer-content {
    display: flex;
    justify-content: space-evenly;
    flex-wrap: wrap;
  }
  
  .footer-bottom {
    border-top: 1px solid #444;
    padding-top: 20px;
    margin: 0;
  }
  // src/config/menuItems.ts

import React from 'react';
import DashboardIcon from '@mui/icons-material/Dashboard';
import PeopleIcon from '@mui/icons-material/People';
import AssignmentIndIcon from '@mui/icons-material/AssignmentInd';
import PhotoLibraryIcon from '@mui/icons-material/PhotoLibrary';
import AccountCircleIcon from '@mui/icons-material/AccountCircle';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday'; 
import EventIcon from '@mui/icons-material/Event';
import FitnessCenterIcon from '@mui/icons-material/FitnessCenter';
import MedicalInformationIcon from '@mui/icons-material/MedicalInformation';
import MeasurementsIcon from '@mui/icons-material/FitnessCenter';
import ShoppingCartIcon from '@mui/icons-material/ShoppingCart';
import AssignmentIcon from '@mui/icons-material/Assignment';
import InfoIcon from '@mui/icons-material/Info';


export interface MenuItem {
  label: string;
  path: string;
  icon: React.ElementType;
  roles: string[];
  subItems?: {
    label: string;
    path: string;
    roles: string[];
  }[];
}

export const menuItems: MenuItem[] = [
  {
    label: 'Dashboard Admin',
    path: '/admin/dashboard',
    icon: DashboardIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Dashboard User',
    path: '/dashboard',
    icon: DashboardIcon,
    roles: ['ROLE_USER'],
  },
  {
    label: 'Sesiones Personal Trainer',
    path: '/dashboard/trainer-sessions',
    icon: CalendarTodayIcon,
    roles: ['ROLE_USER'],
  },
  {
    label: 'Reservar horario personal trainer',
    path: '/trainers/my-calendar',
    icon: CalendarTodayIcon,
    roles: ['ROLE_USER'],
  },
  {
    label: 'Usuarios',
    path: '/admin/users/page/0',
    icon: PeopleIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Dashboard Trainer',
    path: '/trainers/dashboard',
    icon: DashboardIcon,
    roles: ['ROLE_TRAINER'],
  },
  {
    label: 'Planes',
    path: '#', // Para activar el dropdown
    icon: AssignmentIcon,
    roles: ['ROLE_ADMIN'],
    subItems: [
      {
        label: 'Gestión de planes',
        path: '/admin/plans',
        roles: ['ROLE_ADMIN'],
      },
      {
        label: 'Facturas de planes',
        path: '/admin/planes/page/0',
        roles: ['ROLE_ADMIN'],
      },
    ],
  },
  {
    label: 'Administrador de Carrusel',
    path: '/admin/carousel',
    icon: PhotoLibraryIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Editar Perfil',
    path: '/trainers/edit-profile',
    icon: AccountCircleIcon,
    roles: ['ROLE_TRAINER', 'ROLE_USER'],
  },
  {

    label: 'Productos',
    path: '#',
    icon: ShoppingCartIcon,
    roles: ['ROLE_ADMIN'],
    subItems: [
      {
        label: 'Gestión de productos',
        path: '/admin/store/products',
        roles: ['ROLE_ADMIN'],
      },
      {
        label: 'Facturas de productos',
        path: '/admin/facturas/page/0',
        roles: ['ROLE_ADMIN'],
      },
    ],
  },
  {
    label: 'Gestión de Categorías',
    path: '/admin/store/categories',
    icon: ShoppingCartIcon,
    roles: ['ROLE_ADMIN'],
  },
  /*
  {
    label: 'Calendario',
    path: '/dashboard/calendar',
    icon: CalendarTodayIcon,
    roles: ['ROLE_USER'],
  }, */
  {
    label: 'Asignar Disponibilidad',
    path: '/admin/trainer-availability',
    icon: EventIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Agregar Medición',
    path: '/trainers/clients/:clientId/measurements/add',
    icon: MedicalInformationIcon,
    roles: ['ROLE_TRAINER'],
  },
  /*
  {
    label: 'Agregar Rutina',
    path: '/trainers/clients/1/routines/add',
    icon: FitnessCenterIcon,
    roles: ['ROLE_TRAINER'],
  }, */
  {
    label: 'Mediciones',
    path: '/users/measurements',
    icon: MeasurementsIcon,
    roles: ['ROLE_USER'],
  },
  /*
  {
    label: 'Clases Grupales',
    path: '/admin/group-classes/create',
    icon: FitnessCenterIcon,
    roles: ['ROLE_ADMIN'],
  }, */
  /*
  {
    label: 'Asignar Entrenador a Clase',
    path: '/admin/group-classes/assign-trainer',
    icon: AssignmentIndIcon,
    roles: ['ROLE_ADMIN'],
  }, */
  /*
  {
    label: 'Clases Disponibles',
    path: '/users/group-classes/available',
    icon: FitnessCenterIcon,
    roles: ['ROLE_USER'],
  }, */


  // ⚠️ Antes estaba “Facturas” suelto, lo eliminamos para agruparlo en “Productos”:
  // {
  //   label: 'Facturas',
  //   path: '/admin/facturas/page/0',
  //   icon: ReceiptIcon,
  //   roles: ['ROLE_ADMIN'],
  // },

  // Este “Planes” al final parece duplicado, podrías borrarlo si ya manejaste planes arriba
  // {
  //   label: 'Planes',
  //   path: '/admin/planes/page/0',
  //   icon: AssignmentIcon,
  //   roles: ['ROLE_ADMIN'],
  // },

  // Tienes un submenú de tienda para usuarios y trainers
  {
    label: 'Tienda',
    path: '/store',
    icon: ShoppingCartIcon,
    roles: ['ROLE_USER', 'ROLE_ADMIN', 'ROLE_TRAINER'],
    subItems: [
      {
        label: 'Proteína',
        path: '/store/proteina',
        roles: ['ROLE_USER', 'ROLE_ADMIN', 'ROLE_TRAINER'],
      },
      {
        label: 'Creatina',
        path: '/store/creatina',
        roles: ['ROLE_USER', 'ROLE_ADMIN', 'ROLE_TRAINER'],
      },
    ],
  },

  {
    label: 'Gym Info',
    path: '/admin/gym-info',
    icon: InfoIcon,
    roles: ['ROLE_ADMIN'],
  },
];
export const PROTECTED_PATHS = [
  '/dashboard',
  '/admin/dashboard',
  '/admin/users',
  '/trainers',
  '/admin/carousel',
  '/dashboard/calendar',
  '/admin/trainer-availability',
  '/trainers/clients',
  '/users/measurements',
  '/admin/group-classes',
  '/store/cart',
  '/auth/login',  
    '/admin/store/products',  
    '/admin/store/products/page',
  '/admin/store/categories',
  '/admin/plans',
  '/admin/planes',
  '/admin/facturas',
  '/admin/gym-info',
];


export const getPrimaryRole = (roles: string[]): string => {
    const rolePriority = ['ROLE_ADMIN', 'ROLE_TRAINER', 'ROLE_USER']; // Jerarquía de roles
    for (const role of rolePriority) {
        if (roles.includes(role)) {
            console.log("aqui el rol", role);
            return role;
          }
          
    }
    return 'ROLE_USER'; // Rol predeterminado si no se encuentra otro
  };
  
  // src/Store/hooks/useCategories.ts
import { useState, useEffect } from 'react';
import { getAllCategories } from '../Store/services/CategoryService';
import { Category } from '../Store/services/CategoryService';

export const useCategories = () => {
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchCategories = async () => {
    setLoading(true);
    try {
      const data = await getAllCategories();
      setCategories(data);
    } catch (err) {
      setError('Error al cargar categorías');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  return { categories, loading, error };
};
import { useEffect, useState } from 'react';

/**
 * Recibe un string con la fecha/hora de fin de oferta (ej: "2025-01-31T23:59:59")
 * Retorna la cadena de texto con "Xh Ym Zs" restante, o "¡Terminó!" si ya llegó a 0.
 */
export function useCountdown(discountEnd: string | undefined) {
  const [timeLeft, setTimeLeft] = useState('');

  useEffect(() => {
    if (!discountEnd) {
      setTimeLeft('');
      return;
    }

    const endDate = new Date(discountEnd).getTime();

    function updateCountdown() {
      const now = new Date().getTime();
      const diff = endDate - now;

      if (diff <= 0) {
        setTimeLeft('¡Terminó!');
        return;
      }

      // Calculamos horas, minutos y segundos
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      setTimeLeft(`${hours}h ${minutes}m ${seconds}s`);
    }

    // Lanzamos la actualización de inmediato
    updateCountdown();

    // Actualizamos cada segundo
    const timer = setInterval(updateCountdown, 1000);
    return () => clearInterval(timer);
  }, [discountEnd]);

  return timeLeft;
}
// src/Store/hooks/useProducts.ts
import { useEffect, useState } from 'react';
import { Product } from '../Store/interface/Product';
import {
  advancedSearchProducts,
  getDistinctBrands,
  getProductsBySearch,
  getDistinctFlavors,
} from '../Store/services/ProductService';

interface PaginatorState {
  totalPages: number;
  number: number;
  first: boolean;
  last: boolean;
}

interface UseProductsProps {
  searchTerm: string;
  category: string | null;
  pageNumber: number;
}

interface UseProductsReturn {
  products: Product[];
  paginator: PaginatorState;
  loading: boolean;
  sortBy: string;
  setSortBy: React.Dispatch<React.SetStateAction<string>>;
  checkBoxInStock: boolean;
  setCheckBoxInStock: React.Dispatch<React.SetStateAction<boolean>>;
  selectedBrands: string[];
  setSelectedBrands: React.Dispatch<React.SetStateAction<string[]>>;
  selectedFlavors: string[];
  setSelectedFlavors: React.Dispatch<React.SetStateAction<string[]>>;
  priceRange: number[];
  setPriceRange: React.Dispatch<React.SetStateAction<number[]>>;
  brands: string[];
  flavors: string[];     
}

export const useProducts = ({
  searchTerm,
  category,
  pageNumber,
}: UseProductsProps): UseProductsReturn => {
  // Estados internos del hook
  const [products, setProducts] = useState<Product[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    totalPages: 0,
    number: 0,
    first: true,
    last: false,
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [brands, setBrands] = useState<string[]>([]);
  const [flavors, setFlavors] = useState<string[]>([]);   

  // Estados para ordenamiento y filtros
  const [sortBy, setSortBy] = useState<string>('price_asc');
  const [checkBoxInStock, setCheckBoxInStock] = useState<boolean>(false);
  const [selectedBrands, setSelectedBrands] = useState<string[]>([]);
  const [selectedFlavors, setSelectedFlavors] = useState<string[]>([]);
  const [priceRange, setPriceRange] = useState<number[]>([0, 100000]);

  const isSearching = searchTerm.trim() !== '';

  useEffect(() => {
    const fetchProductsAndFilters = async () => {
      setLoading(true);
      try {
        // 1) Obtener Marcas únicas
        const brandsResponse = await getDistinctBrands();
        setBrands(brandsResponse);

        // 2) Obtener Sabores únicos <-- Aquí
        const flavorsResponse = await getDistinctFlavors();
        setFlavors(flavorsResponse);

        // 3) Cargar productos
        if (isSearching) {
          // Buscar en backend por nombre, o traer todo y filtrar:
          const foundProducts = await getProductsBySearch(searchTerm);
          setProducts(foundProducts);
          // Reiniciar paginador
          setPaginator({ totalPages: 0, number: 0, first: true, last: true });
        } else {
          // Filtros combinados
          const filters = {
            category: category || null,
            inStock: checkBoxInStock ? true : undefined,
            brands: selectedBrands,
            flavors: selectedFlavors,   // <-- Añade los sabores seleccionados
            minPrice: priceRange[0],
            maxPrice: priceRange[1],
          };

          // Llamada avanzada con paginación
          const response = await advancedSearchProducts({
            page: pageNumber,
            size: 12,
            sortBy,
            ...filters,
          });

          setProducts(response.content);
          setPaginator({
            totalPages: response.totalPages,
            number: response.number,
            first: response.first,
            last: response.last,
          });
        }

      } catch (error) {
        console.error('Error al cargar productos:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchProductsAndFilters();
  }, [
    isSearching,
    searchTerm,
    category,
    pageNumber,
    sortBy,
    checkBoxInStock,
    selectedBrands,
    selectedFlavors,
    priceRange,
  ]);

  return {
    products,
    paginator,
    loading,
    sortBy,
    setSortBy,
    checkBoxInStock,
    setCheckBoxInStock,
    selectedBrands,
    setSelectedBrands,
    selectedFlavors,
    setSelectedFlavors,
    priceRange,
    setPriceRange,
    brands,
    flavors, 
  };
};

export interface LoginCredentials {
    password: string;
    email: string;
}
import { UserInterface } from "./UserInterface";


export interface AuthState {
  status: 'checking' | 'authenticated' | 'not-authenticated';
  user: UserInterface | null;
  isAuth: boolean;
  isAdmin: boolean;
  trainer?: boolean;
  roles: string[]; // Array de roles en formato string
  token: string | null;
  profileImageUrl?: string; 
  errorMessage?: string;
}

// src/interfaces/UserInterface.ts

// src/interfaces/UserInterface.ts

export interface Role {
  authority: string;
}

export interface TrainerDetails {
  specialization?: string;
  experienceYears?: number;
  availability?: boolean;
  monthlyFee?: number;
  title?: string;
  studies?: string;
  certifications?: string;
  description?: string;
  instagramUrl?: string;
  whatsappNumber?: string;
}

export interface UserInterface {
  id: number;
  username: string;
  password?: string;
  email: string;
  admin: boolean;
  trainer?: boolean;
  role?: Role | string;
  roles?: Role[];
  profileImageUrl?: string;
  // Detalles específicos de entrenadores
  trainerDetails?: TrainerDetails;
    /**
   * Campo opcional para adjuntar un archivo de certificación (PDF, imagen, etc.)
   * cuando se marca el usuario como Trainer.
   */
    certificationFile?: File;
}






// UserInterface.ts
export interface UserState {
    id?: string;
    username: string;
    password: string;
    email: string;
    admin: boolean;
    trainer: boolean;
      // Agregar la propiedad 'role'
    role: string;
    // O si manejas roles como un array:
    roles: string[];
    // Otros campos...
    profileImageUrl: string;
}
.homepage-container {
  text-align: center;
  background: linear-gradient(135deg, #1976d2, #1565c0);
  color: white;
  padding: 50px 0;
  margin: 0;
  width: 100%;
  box-sizing: border-box;
  font-family: 'Arial', sans-serif;
}

.features-container {
  display: flex;
  justify-content: space-evenly;
  gap: 20px;
  flex-wrap: wrap;
  margin-top: 30px;
}

.feature-item {
  text-align: center;
  width: 160px;
  cursor: pointer;
  transition: transform 0.3s, box-shadow 0.3s;
}

.feature-item img {
  width: 160px;
  height: 160px;
  border-radius: 50%;
  border: 5px solid #ffffff;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s, box-shadow 0.3s;
}

.feature-item img:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.feature-item p {
  margin-top: 10px;
  font-weight: bold;
  font-size: 14px;
  color: #f3f3f3;
  text-transform: uppercase;
}

.feature-item:hover {
  transform: scale(1.05);
}

.promo-section {
  text-align: center;
  margin: 50px 0;
  padding: 20px;
  background: linear-gradient(135deg, #1e88e5, #1565c0);
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.promo-section h2 {
  color: #f0f0f0;
  font-size: 24px;
  margin-bottom: 20px;
  text-shadow: 2px 2px rgba(0, 0, 0, 0.2);
}

.promo-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  width: 100%;
}

.promo-item {
  position: relative;
  overflow: hidden;
  width: 100%;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s, box-shadow 0.3s;
}

.promo-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 10px;
  transition: transform 0.3s;
}

.promo-item:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.promo-item p {
  position: absolute;
  bottom: 20px;
  left: 20px;
  color: white;
  font-size: 18px;
  font-weight: bold;
  text-shadow: 2px 2px rgba(0, 0, 0, 0.5);
  background: rgba(0, 0, 0, 0.5);
  padding: 5px 10px;
  border-radius: 5px;
  transition: background 0.3s;
}

.promo-item:hover p {
  background: rgba(0, 0, 0, 0.8);
}

.discount-product-card {
  background-color: #fff;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  color: #333;
  transition: box-shadow 0.3s;
}

.discount-product-card {
  width: 300px;         /* ancho fijo */
  height: 380px;        /* alto fijo */
  background-color: #fff;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  color: #333;
  transition: box-shadow 0.3s;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  margin: 0 auto; 
}

.discount-product-card:hover {
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.discount-product-image {
  width: 100%;
  height: 180px;
  object-fit: contain; 
  border-radius: 6px;
  margin-bottom: 8px;
}


.discount-product-name {
  margin: 0;
  font-size: 1rem;
  font-weight: bold;
  color: #333;
}

.discount-product-price-section {
  margin-top: 8px;
}

.original-price {
  color: #999;
  font-size: 0.9rem;
}

.final-price {
  color: red;
  font-weight: bold;
  font-size: 1.1rem;
  margin: 0;
}

.discount-reason {
  font-size: 0.9rem;
  font-style: italic;
  color: #e53935;
  margin: 0;
}

.no-discount-price {
  font-size: 1.1rem;
  color: #222;
  font-weight: bold;
  margin: 0;
}

.swiper-button-next, .swiper-button-prev {
  color: white !important; 
  font-size: 24px !important;
  text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7); 
}

.swiper-button-next:hover, .swiper-button-prev:hover {
  transform: scale(1.2); 
}



export * from './AppRouter';import apiClient from '../Apis/apiConfig';

export const getDiscountedProducts = async () => {
  try {
    // Ajusta la ruta según tu backend (aquí asumo '/store/products/offers')
    const response = await apiClient.get('/store/products/offers');
    return response.data;
  } catch (error) {
    console.error('Error al obtener productos en oferta:', error);
    throw error;
  }
};

// src/utils/discount.ts
import { Product } from '../Store/interface/Product';

export const getDiscountedPrice = (product: Product) => {
  const now = new Date();
  const start = product.discountStart ? new Date(product.discountStart) : null;
  const end = product.discountEnd ? new Date(product.discountEnd) : null;
  
  let isDiscountActive = false;
  if (
    product.discountPercent && 
    product.discountPercent > 0 && 
    start && 
    end && 
    now >= start && 
    now <= end
  ) {
    isDiscountActive = true;
  }

  const originalPrice = product.price;
  let finalPrice = product.price;
  if (isDiscountActive) {
    finalPrice = finalPrice - (finalPrice * product.discountPercent / 100);
  }

  return { originalPrice, finalPrice, isDiscountActive, discountReason: isDiscountActive ? product.discountReason : null };
};


import apiClient from '../Apis/apiConfig';


export const getCarouselImages = async () => {
  try {
    const response = await apiClient.get('/carousel/images');
    console.log("aqui esta la data",response);
    return response.data;
  } catch (error) {
    console.error('Error al obtener las imágenes del carrusel:', error);
    throw error;
  }
};







export { getCarouselImages } from './getCarouselImages';
export { uploadCarouselImage } from './uploadCarouselImage';import privateApi from "../Apis/apiConfig";

export const uploadCarouselImage = async (
  file: File,
  caption: string,
  orderNumber: number
) => {
  try {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('caption', caption);
    formData.append('orderNumber', orderNumber.toString());

    const response = await privateApi.post('/carousel/images', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });

    return response.data;
  } catch (error) {
    console.error('Error al subir imagen al carrusel:', error);
    throw error;
  }
};




// src/services/TrainerService.ts

import apiClient from '../../Apis/apiConfig';

export const getWeeklySlots = async (trainerId: number) => {
  try {
    const response = await apiClient.get(`/trainer-schedule/${trainerId}/weekly-slots`);
    console.log("aqui los horarios disponibles",response.data);
    return response.data;
  } catch (error) {
    console.error('Error al obtener los slots de tiempo:', error);
    throw error;
  }
};

/**
 * Reserva un slot de tiempo para un entrenador específico.
 * @param trainerId ID del entrenador.
 * @param slotStart ISO string de la hora de inicio del slot.
 * @returns Respuesta de la reserva.
 */
export const bookSlot = async (trainerId: number, slotStart: string) => {
    try {
      const response = await apiClient.post(
        '/trainer-schedule/book',
        null, // Enviar cuerpo vacío
        {
          params: { trainerId, slotStart }, // Enviar ambos como parámetros de consulta
        }
      );
      return response;
    } catch (error: any) {
      console.error('Error al reservar el slot:', error);
      throw error;
    }
  };
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { getCarouselImages } from '../services/getCarouselImages';

// Definimos el estado inicial del slice
interface CarouselState {
  images: Array<{
    id: number;
    imageUrl: string;
    caption: string;
    orderNumber: number;
  }>;
  loading: boolean;
  error: string | null;
}

// Estado inicial
const initialState: CarouselState = {
  images: [],
  loading: false,
  error: null,
};

// Creamos una thunk asincrónica que haga la petición al backend
export const fetchCarouselImages = createAsyncThunk(
  'carousel/fetchImages',
  async (_, { rejectWithValue }) => {
    try {
      const data = await getCarouselImages();  // Petición a tu backend
      return data;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

// Creamos el slice
export const carouselSlice = createSlice({
  name: 'carousel',
  initialState,
  reducers: {
    // Si deseas algún reducer extra, puedes ponerlo aquí.
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchCarouselImages.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCarouselImages.fulfilled, (state, action: PayloadAction<any[]>) => {
        state.loading = false;
        state.error = null;
        state.images = action.payload; // Guardamos las imágenes
      })
      .addCase(fetchCarouselImages.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string || 'Error al cargar imágenes';
      });
  },
});

export default carouselSlice.reducer;
// src/interfaces/Payment.ts

export interface PaymentPlanDTO {
    paymentId: number;
    planId: number;
    username: string;
    transactionAmount: number;
    status: string;
    paymentMethod: string | null;
    paymentDate: string;
    subscriptionStartDate: string;
    subscriptionEndDate: string;
    trainerSubscriptionStartDate: string;
    trainerSubscriptionEndDate: string;
    personalTrainerName: string | null;
  }
  
  export interface PaymentProductDTO {
    paymentId: number;
    username: string;
    paymentMethod: string | null;
    paymentDate: string;
    transactionAmount: number;
    productName: string;
  }
  export interface Plan {
    id?: number;
    name: string;
    price: number;
    description?: string;
    discount?: number;
    discountReason?: string; // <-- nuevo
    versionNumber?: number;
    active?: boolean;
  }
  
  export interface Product {
  id?: number;
  name: string;
  description?: string;
  imageUrl?: string;
  price: number;
  category: {
    id: number;
    name: string;
  };
  stock: number;
  flavor: string;
  brand: string;
  discountPercent: number;
  discountReason: string;
  discountStart?: string; // Agregar si es necesario
  discountEnd?: string;   // Agregar si es necesario
}




export interface Trainer {
  id: number;
  username: string;
  email: string;
  specialization: string;
  experienceYears: number;
  availability: boolean;
  profileImageUrl: string;
  title: string;
  studies: string;
  certifications: string;
  description: string;
  monthlyFee: number; 
  instagramUrl?: string | null;
  whatsappNumber?: string | null;
  certificationFileUrl?: string | null;
}// src/services/CategoryService.ts
import apiClient from '../../Apis/apiConfig'; // asumiendo que apiClient ya está configurado

export interface Category {
  id: number;
  name: string;
}

export const getAllCategories = async (): Promise<Category[]> => {

  const response = await apiClient.get('/store/categories');

  return response.data;
};
    // src/Store/services/ProductService.ts
    import apiClient from '../../Apis/apiConfig';
import { Product } from '../interface/Product';
import { CartItem } from '../Store/slices/cartSlice';
import { Category } from './CategoryService';


interface ProductPage {
  content: Product[];
  number: number;      // página actual
  totalPages: number;  // total de páginas
  first: boolean;
  last: boolean;
 
}
  interface AdvancedSearchPayload {
    page: number;
    size: number;
    sortBy: string;
  
    // Filtros
    category?: string|null;
    inStock?: boolean;
    brands?: string[];
    flavors?: string[];
    minPrice?: number;
    maxPrice?: number;
    // ...
  }

  
  export const getAllProducts = async (): Promise<Product[]> => {
      console.log("AQUI LLEGA");
    const response = await apiClient.get('/store/products');
    console.log("AQUI LA RESPONSE",response);
    return response.data;
  };

 
  export const getProductsByCategory = async (categoryName: string): Promise<Product[]> => {
    const response = await apiClient.get('/store/products', {
      params: {
        category: categoryName,
      },
    });
    return response.data;
  };


  export const getProductById = async (id: number) => {
    console.log("AQUI ESTA EL ID DEL PRODUCTO",id);
    const response = await apiClient.get(`/store/products/${id}`);
    console.log("AQUI LA RESPONSE",response);
    return response.data;
  };

  export const getProductsPage = async (
    page: number,
    size: number,
    category?: string,
    sortBy?: string
  ): Promise<ProductPage> => {
    // Parametrizamos la llamada
    const params: any = {};
    if (category) params.category = category;
    if (sortBy) params.sortBy = sortBy;
    params.size = size;
  
    const response = await apiClient.get(`/store/products/page/${page}`, { params });
    console.log("obtener datos paginacion getProductPage",response);
    return response.data;  
  };
  

  // ProductService.ts (frontend)
export const getProductsBySearch = async (term: string): Promise<Product[]> => {
  const response = await apiClient.get('/store/products/search', {
    params: { term },
  });
  console.log("response",response);
  return response.data; // un array de Product
};

export const createProductPreference = async (items: CartItem[]) => {
 
    // Enviar solicitud POST con los items del carrito
    const response = await apiClient.post('/payment/create_product_preference', items);

    console.log('Preferencia de pago creada:', response.data);
    return response.data;  // Retorna el punto de inicio del checkout (initPoint)
    

};

export const getDistinctBrands = async (): Promise<string[]> => {
  const response = await apiClient.get('/store/products/brands');
  return response.data;
};

export const getDistinctFlavors = async (): Promise<string[]> => {
  const response = await apiClient.get('/store/products/flavors');
  return response.data;
};


export async function advancedSearchProducts(
  payload: AdvancedSearchPayload
): Promise<ProductPage> {
  const {
    page,
    size,
    sortBy,
    category,
    inStock,
    brands,
    flavors,
    minPrice,
    maxPrice,
  } = payload;

  const params: any = {
    page,
    size,
    sortBy,
    minPrice,
    maxPrice,
  };
  if (category) params.category = category;
  if (inStock !== undefined) params.inStock = inStock;
  if (brands && brands.length > 0) params.brands = brands.join(',');
  if (flavors && flavors.length > 0) params.flavors = flavors.join(',');

  const response = await apiClient.get('/store/products/search2', { params });
  console.log("search2 response", response);
  return response.data;
}

export const getAllCategories = async (): Promise<Category[]> => {
  const response = await apiClient.get('/store/categories');
  return response.data;
};

export const createProduct = async (formData: FormData): Promise<Product> => {
  const response = await apiClient.post('/store/products', formData, {
    headers: { 'Content-Type': 'multipart/form-data' },
  });
  return response.data;
};
export const updateProduct = async (id: number, formData: FormData): Promise<Product> => {
  console.log("aqui formData",formData);
  const response = await apiClient.put(`/store/products/${id}`, formData, {
    headers: { 'Content-Type': 'multipart/form-data' },
  });
  return response.data;
};



export const deleteProduct = async (id: number): Promise<void> => {
  await apiClient.delete(`/store/products/${id}`);
};








// src/Store/slices/cartSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Product } from '../../interface/Product';

// Estructura para guardar producto + cantidad
export interface CartItem {
  product: Product;
  quantity: number;
}

// Estado inicial del slice
interface CartState {
  items: CartItem[];
}

// Estado inicial
const initialState: CartState = {
  items: [],
};

export const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    // Agregar un producto al carrito con una cantidad dada
    addToCart: (state, action: PayloadAction<{ product: Product; quantity: number }>) => {
      const { product, quantity } = action.payload;

      // Ver si el producto ya está en el carrito
      const existingItem = state.items.find((item) => item.product.id === product.id);

      if (existingItem) {
        // Si existe, incrementamos la cantidad
        existingItem.quantity += quantity;
      } else {
        // Si no existe, lo agregamos
        state.items.push({ product, quantity });
      }
    },

    // Quitar un producto del carrito
    removeFromCart: (state, action: PayloadAction<number>) => {
      const productId = action.payload;
      state.items = state.items.filter((item) => item.product.id !== productId);
    },

    // Incrementar la cantidad de un producto en 1
    increaseQuantity: (state, action: PayloadAction<number>) => {
      const productId = action.payload;
      const item = state.items.find((item) => item.product.id === productId);
      if (item) {
        item.quantity += 1;
      }
    },

    // Decrementar la cantidad de un producto en 1 (sin bajar de 1)
    decreaseQuantity: (state, action: PayloadAction<number>) => {
      const productId = action.payload;
      const item = state.items.find((item) => item.product.id === productId);
      if (item && item.quantity > 1) {
        item.quantity -= 1;
      }
    },
  },
});

// Exportar actions y reducer
export const {
  addToCart,
  removeFromCart,
  increaseQuantity,
  decreaseQuantity,
} = cartSlice.actions;

export default cartSlice.reducer;
// src/Trainers/services/trainerClientService.ts
import apiClient from '../../Apis/apiConfig';

export interface BodyMeasurement {
  weight: number;
  height: number;
  bodyFatPercentage: number;
  date: string; // Formato ISO: "YYYY-MM-DDTHH:mm:ss"
}

export interface RoutineRequest {
  title: string;
  description: string;
  assignedDate: string; // también en formato ISO
}

export const addBodyMeasurement = async (clientId: number, measurement: BodyMeasurement) => {
  const response = await apiClient.post(`/trainers/clients/${clientId}/measurements`, measurement);
  return response.data;
};

export const addRoutine = async (clientId: number, routine: RoutineRequest) => {
  const response = await apiClient.post(`/trainers/clients/${clientId}/routines`, routine);
  return response.data;
};
// src/Trainers/services/TrainerService.ts

import { UserInterface } from '../../Auth/Interfaces/UserInterface';
import apiClient from '../../Apis/apiConfig';
import axios from 'axios';

// src/Trainers/services/TrainerService.ts

export const updateTrainerProfile = async (formData: FormData): Promise<UserInterface> => {
  console.log("AQUI ESTA LA DATA (Formulario):", {
    username: formData.get('username'),
    email: formData.get('email'),
    password: formData.get('password'),
    file: formData.get('file'),
  });
  
  const token = sessionStorage.getItem('token');
  
  if (!token) {
    throw new Error('Token de autenticación no encontrado');
  }

  const response = await apiClient.put<UserInterface>('/profile/update', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      Authorization: `Bearer ${token}`,
    },
  });

  console.log("Respuesta del servidor:", response.data);
  return response.data; // Retorna solo los datos del usuario
};



export const getClients = async () => {
  try {
    const response = await apiClient.get('/trainers/clients');
    console.log("AQUI LOS USUARIOS",response);
    return response.data;
  } catch (error) {
    console.error('[TrainerClientService] Error fetching clients:', error);
    throw error;
  }
};

export interface ActiveClientInfo {
  clientId: number;
  clientName: string;
  clientEmail: string;
  planName?: string;
  planStart?: string;  
  planEnd?: string;      
  trainerStart?: string;  
  trainerEnd?: string;    
}

export const getActiveClientsInfo = async (): Promise<ActiveClientInfo[]> => {
  const response = await apiClient.get('/trainers/active-clients-info');
  return response.data;
};

export interface TrainerCalendarEvent {
  id: number;
  title: string;
  start: string;  // ISO date string
  end:   string;  // ISO date string
  eventType: 'PERSONAL' | 'GROUP';  // o el string que tu backend devuelva
}

/**
 * Obtiene TODOS los eventos (personales + grupales) del entrenador con ID `trainerId`.
 */
export const getTrainerCalendarEvents = async (trainerId: number): Promise<TrainerCalendarEvent[]> => {
  const response = await apiClient.get(`/trainer-schedule/${trainerId}/calendar`);
  console.log("ACA LA RESPONSE",response);
  return response.data;
};

// src/types/sweetalert2-react-content.d.ts

declare module 'sweetalert2-react-content' {
    import Swal, { SweetAlertOptions, SweetAlertResult } from 'sweetalert2';
  
    interface ReactSwal extends typeof Swal {
      fire(options: SweetAlertOptions): Promise<SweetAlertResult<any>>;
    }
  
    function withReactContent(Swal: typeof Swal): ReactSwal;
  
    export default withReactContent;
  }
  // src/hooks/useAvailableClasses.ts
import { useEffect, useState } from 'react';
import Swal from 'sweetalert2';  // Importar SweetAlert
import { getAvailableGroupClasses, GroupClass, bookGroupClass } from '../../Users/services/groupClassService';

export const useAvailableClasses = () => {
  const [classes, setClasses] = useState<GroupClass[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchClasses = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getAvailableGroupClasses();
      setClasses(data);
    } catch (err: any) {
      setError('Error al obtener las clases disponibles');
    } finally {
      setLoading(false);
    }
  };

  const bookClassById = async (classId: number) => {
    try {
      setLoading(true);
      setError(null);
      await bookGroupClass(classId);
      
      // Mostrar SweetAlert en caso de éxito
      Swal.fire({
        title: 'Reserva exitosa',
        text: 'Has reservado con éxito. Por favor, llega 5 minutos antes de la clase.',
        icon: 'success',
        confirmButtonText: 'Entendido'
      });

      // Refrescar la lista automáticamente después de reservar
      await fetchClasses();  
      
    } catch (err: any) {
      // Si el error es porque ya tiene una reserva
      if (err.response && err.response.data === "Ya tienes una reserva en esta clase") {
        Swal.fire({
          title: 'Reserva duplicada',
          text: 'Ya tienes una reserva para esta clase.',
          icon: 'info',
          confirmButtonText: 'OK'
        });
      } else {
        // Mensaje genérico para otros errores
        Swal.fire({
          title: 'Error al reservar',
          text: 'Hubo un problema al intentar reservar la clase. Verifica tu plan activo o el rango de reserva.',
          icon: 'error',
          confirmButtonText: 'Entendido'
        });
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchClasses();
  }, []);

  return { classes, loading, error, bookClassById };
};


export interface GroupClass {
    id: number;
    className: string;
    startTime: string; // ISO string
    endTime: string;   // ISO string
    maxParticipants: number;
    assignedTrainer?: {
      id: number;
      user: {
        username: string;
        email: string;
      };
      specialization?: string;
    };
  }

  export interface CalendarEventDTO {
    id: number;
    title: string;
    start: string;
    end: string;
    eventType: string;
  }
  import {  UserInterface } from "../../Auth/Interfaces/UserInterface";

export interface BodyMeasurement {
    id: number;
    client: UserInterface;
    trainer: UserInterface; // Cambiado a UserInterface
    clientName: string | null;
    weight: number | null;
    height: number | null;
    bodyFatPercentage: number | null;
    date: string; // ISO string
    injuries: string;
    medications: string;
    otherHealthInfo: string;
    currentlyExercising: boolean | null;
    sportsPracticed: string;
    currentWeight: number | null;
    bmi: number | null;
    relaxedArm: number | null;
    waist: number | null;
    midThigh: number | null;
    flexedArm: number | null;
    hips: number | null;
    calf: number | null;
    tricepFold: number | null;
    subscapularFold: number | null;
    bicepFold: number | null;
    suprailiacFold: number | null;
    sumOfFolds: number | null;
    percentageOfFolds: number | null;
    fatMass: number | null;
    leanMass: number | null;
    muscleMass: number | null;
    idealMinWeight: number | null;
    idealMaxWeight: number | null;
    trainerRecommendations: string;
    age: number | null;
    
}
.receipt-container {
    max-width: 800px;
    margin: 2rem auto;
    padding: 20px;
  }
  
  .print-button {
    background: #007bff;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 20px;
  }
  
  .print-button:hover {
    background: #0056b3;
  }
  
  .receipt {
    border: 2px solid #000;
    padding: 30px;
    background: #fff;
    font-family: 'Courier New', monospace;
  }
  
  .receipt-header {
    text-align: center;
    border-bottom: 2px dashed #000;
    margin-bottom: 20px;
    padding-bottom: 20px;
  }
  
  .company-info h2 {
    margin: 5px 0;
    font-size: 1.5em;
  }
  
  .company-info p {
    margin: 3px 0;
    font-size: 0.9em;
  }
  
  .receipt-details {
    margin: 20px 0;
  }
  
  .detail-row {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    padding: 5px 0;
    border-bottom: 1px dashed #ddd;
  }
  
  .status-success {
    color: #28a745;
    font-weight: bold;
  }
  
  .products-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
  }
  
  .products-table th,
  .products-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }
  
  .products-table th {
    background-color: #f8f9fa;
  }
  
  .total-section {
    margin-top: 20px;
    border-top: 2px solid #000;
    padding-top: 15px;
  }
  
  .total-row {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.1em;
  }
  
  .receipt-footer {
    text-align: center;
    margin-top: 30px;
    padding-top: 15px;
    border-top: 2px dashed #000;
    font-size: 0.9em;
  }
  
  @media print {
    .print-button {
      display: none;
    }
    
    .receipt {
      border: none;
      padding: 0;
    }
    
    body {
      background: #fff !important;
      margin: 0;
      padding: 20px;
    }
  }// src/api/groupClassService.ts

import apiClient from '../../Apis/apiConfig';
import { GroupClass } from '../interfaces/GroupClass';



export const getAvailableGroupClasses = async (): Promise<GroupClass[]> => {
  const response = await apiClient.get('/group-classes/available');
  return response.data;
};

export const bookGroupClass = async (classId: number) => {
  const response = await apiClient.post(`/group-classes/${classId}/book`);
  return response.data;
};

// Ya teníamos createGroupClass y assignTrainerToClass, las dejamos como están.
// src/services/measurementService.ts

import apiClient from '../../Apis/apiConfig';
import { BodyMeasurement } from '../../Trainers/services/trainerClientService';


const getMeasurements = (clientId: number) => {
  console.log("id cient",clientId);
  return apiClient.get<BodyMeasurement[]>(`/clients/${clientId}/measurements`);
};

export default {
  getMeasurements,
};
